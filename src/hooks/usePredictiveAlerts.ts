import { useState, useEffect } from 'react';
import { useQuery } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { createNotification } from '@/services/notifications';
import { toast } from 'sonner';

interface PredictiveAlert {
  id: string;
  type: 'deadline_risk' | 'performance_decline' | 'compliance_risk' | 'goal_deviation';
  title: string;
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  probability: number; // 0-1
  daysToEvent: number;
  affectedEntity: {
    type: string;
    id: string;
    name: string;
  };
  predictedImpact: string;
  preventiveActions: string[];
  autoGenerated: boolean;
  createdAt: Date;
}

interface PredictionModel {
  licenses: () => Promise<PredictiveAlert[]>;
  goals: () => Promise<PredictiveAlert[]>;
  emissions: () => Promise<PredictiveAlert[]>;
  compliance: () => Promise<PredictiveAlert[]>;
}

export const usePredictiveAlerts = () => {
  const [alerts, setAlerts] = useState<PredictiveAlert[]>([]);
  const [isProcessing, setIsProcessing] = useState(false);

  // Fetch data for predictions
  const { data: predictionData, isLoading } = useQuery({
    queryKey: ['predictive-data'],
    queryFn: async () => {
      const [licensesResult, goalsResult, emissionsResult, tasksResult] = await Promise.all([
        supabase.from('licenses').select('*'),
        supabase.from('goals').select(`
          *,
          goal_progress_updates(*)
        `),
        supabase.from('calculated_emissions').select(`
          *,
          activity_data(*)
        `).order('calculation_date', { ascending: false }).limit(200),
        supabase.from('compliance_tasks').select('*')
      ]);

      return {
        licenses: licensesResult.data || [],
        goals: goalsResult.data || [],
        emissions: emissionsResult.data || [],
        tasks: tasksResult.data || []
      };
    },
    staleTime: 10 * 60 * 1000, // 10 minutes
  });

  // Prediction models
  const predictionModels: PredictionModel = {
    // License expiration predictions
    licenses: async () => {
      if (!predictionData?.licenses) return [];
      
      const alerts: PredictiveAlert[] = [];
      const now = new Date();

      for (const license of predictionData.licenses) {
        const expirationDate = new Date(license.expiration_date);
        const daysToExpiration = Math.ceil((expirationDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));

        // Predict based on renewal patterns and lead times
        if (daysToExpiration <= 90 && daysToExpiration > 0) {
          const severity = daysToExpiration <= 30 ? 'critical' : 
                          daysToExpiration <= 45 ? 'high' : 
                          daysToExpiration <= 60 ? 'medium' : 'low';

          const probability = Math.max(0.3, (90 - daysToExpiration) / 90);

          alerts.push({
            id: `license-expiry-${license.id}`,
            type: 'deadline_risk',
            title: `Licença "${license.name}" próxima do vencimento`,
            description: `Renovação deve ser iniciada em ${Math.max(0, daysToExpiration - 45)} dias para evitar atrasos`,
            severity,
            probability,
            daysToEvent: daysToExpiration,
            affectedEntity: {
              type: 'license',
              id: license.id,
              name: license.name
            },
            predictedImpact: 'Risco de interrupção operacional e multas regulatórias',
            preventiveActions: [
              'Iniciar processo de renovação imediatamente',
              'Contatar órgão emissor para verificar requisitos',
              'Preparar documentação necessária',
              'Agendar vistorias se necessário'
            ],
            autoGenerated: true,
            createdAt: new Date()
          });
        }
      }

      return alerts;
    },

    // Goal achievement predictions
    goals: async () => {
      if (!predictionData?.goals) return [];
      
      const alerts: PredictiveAlert[] = [];
      const now = new Date();

      for (const goal of predictionData.goals) {
        const deadline = new Date(goal.deadline_date);
        const daysToDeadline = Math.ceil((deadline.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
        
        if (daysToDeadline > 0 && daysToDeadline <= 365) {
          // Get current progress from goal_progress_updates
          const latestProgress = goal.goal_progress_updates && goal.goal_progress_updates.length > 0 
            ? goal.goal_progress_updates[goal.goal_progress_updates.length - 1]
            : null;
          
          const currentProgress = latestProgress?.progress_percentage || 0;
          
          // Simple progress prediction based on current progress and time elapsed
          const startDate = new Date(goal.created_at);
          const totalDays = Math.ceil((deadline.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
          const daysElapsed = totalDays - daysToDeadline;
          const progressRate = currentProgress / Math.max(daysElapsed, 1);
          const projectedProgress = progressRate * totalDays;

          if (projectedProgress < 80 && daysToDeadline <= 90) {
            const probability = Math.min(0.9, (80 - projectedProgress) / 80);
            
            alerts.push({
              id: `goal-risk-${goal.id}`,
              type: 'goal_deviation',
              title: `Meta "${goal.name}" em risco`,
              description: `Progresso atual (${Math.round(currentProgress)}%) indica possível não cumprimento`,
              severity: projectedProgress < 50 ? 'high' : 'medium',
              probability,
              daysToEvent: daysToDeadline,
              affectedEntity: {
                type: 'goal',
                id: goal.id,
                name: goal.name
              },
              predictedImpact: 'Não cumprimento de objetivos ESG e impacto na reputação',
              preventiveActions: [
                'Acelerar ações implementadas',
                'Alocar recursos adicionais',
                'Revisar estratégia da meta',
                'Implementar ações de recuperação'
              ],
              autoGenerated: true,
              createdAt: new Date()
            });
          }
        }
      }

      return alerts;
    },

    // Emissions trend predictions
    emissions: async () => {
      if (!predictionData?.emissions || predictionData.emissions.length < 10) return [];
      
      const alerts: PredictiveAlert[] = [];
      const emissions = predictionData.emissions.sort((a, b) => 
        new Date(a.calculation_date).getTime() - new Date(b.calculation_date).getTime()
      );

      // Analyze trend over last 3 months
      const threeMonthsAgo = new Date();
      threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
      
      const recentEmissions = emissions.filter(e => 
        new Date(e.calculation_date) >= threeMonthsAgo
      );

      if (recentEmissions.length >= 5) {
        // Simple linear regression for trend
        const trend = calculateTrend(recentEmissions.map((e, index) => ({
          x: index,
          y: e.total_co2e
        })));

        if (trend.slope > 0.1) { // Increasing trend
          const probability = Math.min(0.8, trend.slope / 0.5);
          
          alerts.push({
            id: 'emissions-trend-increase',
            type: 'performance_decline',
            title: 'Tendência de aumento nas emissões detectada',
            description: `Emissões aumentando ${(trend.slope * 30).toFixed(1)}% ao mês`,
            severity: trend.slope > 0.3 ? 'high' : 'medium',
            probability,
            daysToEvent: 30, // Next month projection
            affectedEntity: {
              type: 'emissions',
              id: 'total-emissions',
              name: 'Emissões Totais'
            },
            predictedImpact: 'Não cumprimento de metas de redução de emissões',
            preventiveActions: [
              'Revisar processos operacionais',
              'Implementar medidas de eficiência energética',
              'Investigar causas do aumento',
              'Acelerar projetos de sustentabilidade'
            ],
            autoGenerated: true,
            createdAt: new Date()
          });
        }
      }

      return alerts;
    },

    // Compliance task predictions
    compliance: async () => {
      if (!predictionData?.tasks) return [];
      
      const alerts: PredictiveAlert[] = [];
      const now = new Date();

      const overdueTasks = predictionData.tasks.filter(task => {
        const dueDate = new Date(task.due_date);
        return dueDate < now && task.status === 'Pendente';
      });

      if (overdueTasks.length > 3) {
        alerts.push({
          id: 'compliance-backlog',
          type: 'compliance_risk',
          title: 'Acúmulo de tarefas de compliance',
          description: `${overdueTasks.length} tarefas em atraso podem impactar conformidade`,
          severity: overdueTasks.length > 10 ? 'critical' : overdueTasks.length > 5 ? 'high' : 'medium',
          probability: 0.9,
          daysToEvent: 0,
          affectedEntity: {
            type: 'compliance',
            id: 'tasks-backlog',
            name: 'Tarefas de Compliance'
          },
          predictedImpact: 'Risco aumentado de não conformidade regulatória',
          preventiveActions: [
            'Priorizar tarefas críticas',
            'Alocar recursos para reduzir backlog',
            'Revisar prazos e responsabilidades',
            'Implementar processo de escalação'
          ],
          autoGenerated: true,
          createdAt: new Date()
        });
      }

      return alerts;
    }
  };

  // Helper function for trend calculation
  const calculateTrend = (points: { x: number; y: number }[]) => {
    const n = points.length;
    const sumX = points.reduce((sum, p) => sum + p.x, 0);
    const sumY = points.reduce((sum, p) => sum + p.y, 0);
    const sumXY = points.reduce((sum, p) => sum + (p.x * p.y), 0);
    const sumX2 = points.reduce((sum, p) => sum + (p.x * p.x), 0);

    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;

    return { slope, intercept };
  };

  // Generate all predictions
  const generatePredictions = async () => {
    if (!predictionData || isProcessing) return;

    setIsProcessing(true);
    
    try {
      const [licenseAlerts, goalAlerts, emissionAlerts, complianceAlerts] = await Promise.all([
        predictionModels.licenses(),
        predictionModels.goals(),
        predictionModels.emissions(),
        predictionModels.compliance()
      ]);

      const allAlerts = [
        ...licenseAlerts,
        ...goalAlerts,
        ...emissionAlerts,
        ...complianceAlerts
      ].sort((a, b) => {
        // Sort by severity and probability
        const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
        const severityDiff = severityOrder[b.severity] - severityOrder[a.severity];
        if (severityDiff !== 0) return severityDiff;
        return b.probability - a.probability;
      });

      setAlerts(allAlerts);

      // Create notifications for critical alerts
      const criticalAlerts = allAlerts.filter(a => a.severity === 'critical');
      for (const alert of criticalAlerts.slice(0, 3)) { // Limit to 3 notifications
        try {
          await createNotification(
            alert.title,
            alert.description,
            'warning',
            undefined,
            { alertId: alert.id, type: 'predictive' }
          );
        } catch (error) {
          console.error('Error creating notification:', error);
        }
      }

      if (criticalAlerts.length > 0) {
        toast.warning('Alertas Preditivos', {
          description: `${criticalAlerts.length} alertas críticos detectados`,
          duration: 5000,
        });
      }

    } catch (error) {
      console.error('Error generating predictions:', error);
      toast.error('Erro ao gerar predições');
    } finally {
      setIsProcessing(false);
    }
  };

  // Auto-generate predictions
  useEffect(() => {
    if (predictionData && !isLoading) {
      generatePredictions();
    }
  }, [predictionData, isLoading]);

  const dismissAlert = (alertId: string) => {
    setAlerts(prev => prev.filter(a => a.id !== alertId));
  };

  const getAlertsByType = (type: PredictiveAlert['type']) => {
    return alerts.filter(a => a.type === type);
  };

  const getAlertsBySeverity = (severity: PredictiveAlert['severity']) => {
    return alerts.filter(a => a.severity === severity);
  };

  const getCriticalAlerts = () => getAlertsBySeverity('critical');
  const getUpcomingDeadlines = () => getAlertsByType('deadline_risk');

  return {
    alerts,
    isProcessing: isProcessing || isLoading,
    refreshPredictions: generatePredictions,
    dismissAlert,
    getAlertsByType,
    getAlertsBySeverity,
    getCriticalAlerts,
    getUpcomingDeadlines,
    stats: {
      total: alerts.length,
      critical: alerts.filter(a => a.severity === 'critical').length,
      high: alerts.filter(a => a.severity === 'high').length,
      deadlines: alerts.filter(a => a.type === 'deadline_risk').length,
      avgProbability: alerts.length > 0 
        ? alerts.reduce((sum, a) => sum + a.probability, 0) / alerts.length 
        : 0
    }
  };
};